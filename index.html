<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
    <title>Simplificando Código</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<!-- <link rel="stylesheet" href="css/theme/night.css" id="theme"> -->
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

    <style>
      body {
        /* green or 3F3*/
/*        background: #002;
        background-color: #002;*/
      }
      .reveal h1, .reveal h2 {
        white-space: nowrap;
      }
      .reveal section img {
        border: 0;
      }
      .reveal pre code {
        font-size: 2.7em;
        line-height: 1em;
        padding: 10px;
      }
    </style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<section>
  <h1>Simplificando<br>Código</h1>

  <p>Tute Costa</p>

  <p>https://github.com/tute/refactoring-workshop</p>
</section>

<section data-transition="none">
  <h1>Patrones de<br>Refactorización</h1>

  <aside class="notes">
    Un PATRON es una SOLUCIÓN REUSABLE para un problema recurrente.<br>
    Los PATRONES son MEJORES PRÁCTICAS pulidos por una comunidad.
    Un PATRON es una DESCRIPCIÓN de cómo resolver un problema, que puede ser
    aplicada en distintas situaciones.

    <br><br>

    REFACTORIZAR es reestructurar código sin cambiar su comportamiento visible.
    Ventajas son COMPLEJIDAD REDUCIDA, y mejor LEGIBILIDAD, facilitando el
    MANTENIMIENTO. También es útil para crear una arquitectura EXPRESIVA, con
    nuestros programas usando TÉRMINOS del MUNDO REAL, facilitando la
    COMUNICACIÓN entre distintas personas.

    <br><br>

    Los patrones de refactorización, entonces, son...
  </aside>
</section>

<section>
  <h1>Vamos a ver</h1>
  <ul>
    <li>Tres anomalías comunes en software
    <li>Patrones para refactorizarlas
  </ul>

  <aside class="notes">
    Los patrones permiten poner un límite sobre la cantidad de trabajo
  </aside>
</section>

<section data-transition="none">
  <h1>Vamos a ver</h1>

  <ol>
    <li>👉 <span style="color: #f33">Código confuso</span><br><br>
    <li><span style=""><tt>"NoMethodError: Undefined method on nil"</tt></tt><br><br>
    <li><span style="">Un Método Gigante</span>
  </ol>
</section>

<section data-transition="none">
  <h1>1: Código confuso</h1>

<pre><code data-trim contenteditable>
# Removes duplicates
if hash[row[1]][date] != row[0]
  # ... code ...
</code></pre>

  <aside class="notes" data-markdown>
    * Como un chiste: si hay que EXPLICARLO, es MALO

    * IDEA: Extraer CONCEPTOS relevantes como MÉTODOS bien nombrados
    * Una táctica: convertir comentarios en CÓDIGO EJECUTABLE
  </aside>
</section>

<section data-transition="none">
  <h1>1: Código confuso</h1>

<pre><code data-trim contenteditable>
# Removes duplicates
if hash[row[1]][date] != row[0]
  # ... code ...
</code></pre>

vs

<pre><code data-trim contenteditable>
if remove_duplicates?
  # ... code ...

def remove_duplicates?
  hash[row[1]][date] != row[0]
</code></pre>

  <aside class="notes" data-markdown>
    * Lo más IMPORTANTE arriba
    * El código se DESCRIBE a sí mismo: hace lo que PENSÁS que hace
    * Puede ganar líneas, pero también legibilidad
    * Es más "CORTO" de leer: no hay que entender cómo se computan duplicados
    para inferir lo que hace
    * Conocen este PATRÓN?
  </aside>
</section>

<section data-transition="none">
  <h1>Método que revela<br>la intención</h1>

  <p>Agregar <b>comentarios</b> si no tiene
  <p>Transformarlos en <b>código</b>
  <p>Los <b>comentarios</b> son ahora <b>ejecutables</b>
  <p>El código se <b>describe</b> a sí mismo

</section>

<section>
  <img src="imgs/lets-work-rosie the riveter.jpg" width="500">
</section>

<section data-transition="none">
  <h2>
    Los comentarios son código
    <br><br>
    El código se describe a sí mismo
  </h2>

  <br>

  <h1><span style="color: green">EXITO TOTAL</span><h1>

  <aside class="notes" data-markdown>
    El código debería leerse como un artículo de un diario, que va de lo más importante a detalles de menor relevancia
  </aside>
</section>

<section data-transition="none">
  <h2>Método que revela la intención</h2>

  <p>Es el patrón más <b style="color: green">simple</b></p>

  <div class="fragment">
    <img src="imgs/naming.png">
    <p>Pero también el más <b style="color:#f33">difícil</b></p>
  </div>

  <aside class="notes" data-markdown>
    Parece el patrón más fácil (transformaciones sintácticas), pero es el más difícil, porque implica NOMBRAR cosas

    Dos problemas GRANDES en Computación: invalidar caches y poner nombres

    Y no sólo nombrar, también decidir niveles de ABSTRACCIÓN:

    * ¿Qué cuenta como RESPONSABILIDAD DEL NEGOCIO y qué como mero DETALLE DE
    IMPLEMENTACIÓN?
    * ¿Cómo modelamos cosas del mundo real en código en la computadora?
  </aside>
</section>

<section data-transition="none">
  <h2>Método que revela la intención</h2>

  <img src="imgs/lo-que-facilita-el-diseno.png" width="400">
  <br>
  El diseño puede prescindir de instrucciones

  <aside class="notes" data-markdown>
    No debería llevar mucho tiempo entender qué hace una sección de código, porque ya demasiado confuso es trabajar con software como para además agregarle complejidad no indispensable

    Avdi Grimm lo llamó "ofrecimientos" ("affordances"): qué facilita el diseño intuitivamente, sin necesidad de pensarlo
  </aside>
</section>

<section data-transition="none">
  <h1>Tests</h1>

  <p>Para cambiar código sin cambiar comportamiento

  <h1>Gestor de versiones</h1>

  <p>Para abortar misión

  <aside class="notes" data-markdown>
    Dos prerequisitos

    Escribir código y deshacerlo es TAN PRODUCTIVO COMO escribir código y publicarlo, se aprende del Software y del mundo real también
  </aside>
</section>

<section data-transition="none">
  <h1>Vamos a ver</h1>

  <ol>
    <li>Código confuso -> <span style="color: green">Método que revela la intención</span><br><br>
    <li>👉 <span style="color: #f33"><tt>"NoMethodError: Undefined method on nil"</tt></tt><br><br>
    <li><span style="">Un Método Gigante</span>
  </ol>
</section>

<section data-transition="none">
  <h1>Ey, nil! 👋🏼</h1>

<pre><code data-trim contenteditable>
current_user.name
</code></pre>

<pre><code data-trim contenteditable>
NoMethodError:
undefined method `name'
for nil:NilClass
</code></pre>

  <aside class="notes" data-markdown>
    El PROBLEMA es que en producción no sabemos exactamente dónde falló
  </aside>
</section>

<section data-transition="none">
  <h1>Ey, nil! 👋🏼</h1>

  <code style="color: #f33; font-size: 140%">Undefined method `name' for nil</code>

<pre><code data-trim contenteditable>
session[:user]      # nil
session[:blog_pozt] # nil
array[length + 1]   # nil
@current_uZer       # nil
if false then 1 end # nil
empty_method()      # nil
</code></pre>

<aside class="notes" data-markdown>
    Imaginen que reciben la excepción por mail.

    <br><br>

    De dónde vino la excepción? De un artículo sin foto? De un visitante que no
    se autenticó? De un error de tipeo al buscar en una cookie?

    <br><br>

    `nil` puede venir de:

    * un hash con `nil` como valor para una clave
    * un hash donde se busca con una clave inexistente
    * un arreglo indexado fuera de su rango
    * una variable de instancia inexistente
    * un condicional que evalúa a `false` pero no hay `else` definido
    * un método vacío
  </aside>
</section>

<section data-transition="none">
  <h1>Ey, nil! 👋🏼</h1>

  <p>Un <span style="color:#0f0">símbolo</span> es mejor que <code style="color:#f33">nil</code>:</p>

<pre><code data-trim contenteditable>
def current_user
  User.find(id) || :guest_user
end
</code></pre>
<pre><code data-trim contenteditable>
current_user.name
</code></pre>

  <br>
  <code style="color: #0f0; font-size: 140%">undefined method `name' for :guest_user:Symbol</code>

  <aside class="notes" data-markdown>
    Ahora sabemos sin pensarlo el contexto en el que falló

    En este caso esperábamos un usuario y no un producto o categoría

    Pero seguimos necesitando `if`s en todos lados
  </aside>
</section>

<section data-transition="none">
  <h1>ifs por doquier</h1>

  <p>Donde pueda haber <code style="color:#f33">nil</code> hay que chequear con <code style="color:#f33">if</code></p>
  <pre><code data-trim contenteditable>
if user != :guest_user
  "Hi #{user.name}!"
else
  "Hi guest!"
end
  </code></pre>

  <aside class="notes">

    "Sabés el nombre o te tengo que decir lo que es?"

    <br><br>

    La lógica sobre el significado de un visitante que no está autenticado se desparrama por toda el código

    <br><br>

    Un cambio sobre esta lógica tiene que ocurrir en todos los lugares donde aparezca (ejemplo, internacionalización)
    un cambio conceptual cambia muchos archivos diversos

    <br><br>

    Siempre nos queda algún condicional en el tintero, generando un error en producción

    <br><br>

    Entonces, ¿qué hacemos?
  </aside>
</section>

<section data-transition="none">
  <p>En lugar de <code style="color:#f33">nil</code>, devolver un nuevo
    <span style="color:#0f0">objeto</span></p>

<pre class="fragment"><code data-trim contenteditable>
def user
  User.find(id) || NullUser.new
end
</code></pre>
<pre class="fragment"><code data-trim contenteditable>
class NullUser
  def name; 'guest'; end
end
</code></pre>
<div class="fragment">
Y eliminar condionales:
<pre><code data-trim contenteditable>
# if user
  "Hi #{user.name}!"
# else
#   "Hi guest!"
# end
</code></pre>
</div>

<aside class="notes" data-markdown>
Ahora necesitamos ese único condicional, escondido en el operador `or`
</aside>
</section>

<section>
  <img src="imgs/lets-work Melba Roy Mouton.jpg" width="500">
</section>

<section>
  <h2>Pero... ¿porqué?</h2>
  <img class="fragment" src="imgs/1-kart.gif" width="500">
</section>
<section data-transition="none">
  <h2>Pero... ¿porqué?</h2>
  <img src="imgs/3-graph.png" width="500">
</section>
<section data-transition="none">
  <h2>Pero... ¿porqué?</h2>
  <table>
    <tr>
    <td><img src="imgs/2-747-cafe.png" width="500">
    <td><img class="fragment" src="imgs/2-747.jpg" width="500">
    </tr>
  </table>
</section>
<section data-transition="none">
  <h2>Pero... ¿porqué?</h2>
  <img src="imgs/4-graph.png" width="500">
</section>
<section data-transition="none">
  <h2>Pero... ¿porqué?</h2>
  <img src="imgs/5-graph.png" width="500">
</section>

<section data-transition="none">
  <h1>Vamos a ver</h1>

  <p>Código confuso -> <span style="color: green">Método que revela la intención</span>

  <p> <tt>"Undefined method on nil"</tt> -> <span style="color: green">Objecto Nulo</span><br>

  <p>👉 <span style="color: #f33">Un Método Gigante</span>
</section>

<section>
  <h1>Método Gigante</h1>

  <pre><code data-trim contenteditable style="font-size:120%">
class ExportJob
  # Instance variables
  # Many other methods
  #
  # And...
  def self.row_per_day_format(file_name)
    file = File.open file_name, 'r:ISO-8859-1'
    # hash[NivelConsistencia][date] = [[value, status]]
    hash = { '1' => {}, '2' => {} }
    dates = []
    str = ''

    CSV.parse(file, col_sep: ';').each do |row|
      next if row.empty?
      next if row[0] =~ /^\/\//
      date = Date.parse(row[2])
      (13..43).each do |i|
        measurement_date = date + (i-13)

        # If NumDiasDeChuva is empty it means no data
        value  = row[7].nil? ? -99.9 : row[i]
        status = row[i + 31]
        hash_value = [value, status]

        dates << measurement_date
        hash[row[1]][measurement_date] = hash_value
      end
    end

    dates.uniq.each do |date|
      if !hash['1'][date].nil? && hash['2'][date].nil?
        # Only 'bruto' (good)
        value = hash['1'][date]
        str << "#{date}\t#{value[0]}\t#{value[1]}\n"
      elsif hash['1'][date].nil? && !hash['2'][date].nil?
        # Only 'consistido' (kind of good)
        value = hash['2'][date]
        str << "#{date}\t#{value[0]}\t#{value[1]}\n"
      else
        # 'bruto' y 'consistido' (has new and old data)
        old_value = hash['1'][date]
        new_value = hash['2'][date]
        str << "#{date}\t#{new_value[0]}\t#{old_value[1]}\t#{old_value[0]}\n"
      end
    end

    str
  end
  </code></pre>

  <aside class="notes" data-markdown>
    La ansiedad del "por dónde empiezo". El método tiene variables y distintas piezas de lógica, todas MEZCLADAS en un MISMO CONTEXTO

    Hay mucho ACOPLAMIENTO: cualquier cambio REPERCUTE en el método y potencialmente en su clase contenedora, que también es grande.

    Si aplicamos "Método que revela la intención" tendremos:

    * MUCHOS métodos en la clase, potencialmente colisionando con otros de similar nombre
    * Métodos que requieren MUCHOS ARGUMENTOS (no vamos a polucionar el objeto con variables de instancia para lo que en verdad son variables locales)
    * El riesgo de un sistema con tests fallando por demasiado tiempo, no pudiendo nunca cerrar el refactor

    Es difícil TIRAR DE UN HILO sin desarmar el paño entero

    Hay mucho CONTEXTO COMPARTIDO, hay que aislar el gran método para que los cambios que apliquemos repercutan SÓLO en ese método

    <br><br>

    ¿Qué hacemos?

  </aside>
</section>

<section>
  <h1>Extraer Objeto</h1>

  <ol>
    <li>Crear una <span style="color:#0f0">clase</span> que reciba los mismos argumentos del método
    <li>Copiar y pegar el <span style="color:#0f0">método</span> en la nueva clase vacía
    <li><span style="color:#0f0">Reemplazar</span> el método original con una llamada a la nueva clase
    <li>Aplicar "<span style="color:#0f0">método que revela la intención</span>" sobre la nueva clase
  </ol>
</section>

<section>
  <img src="imgs/lets-work-eniac-women-1940s-720x720.jpg" width="720">
</section>

<section data-transition="none">
  <h1>Therapeutic<br>Refactoring</h1>

  <h3>Katrina Owens</h3>

  <p>
    <a target="_blank" href="http://confreaks.com/videos/1071-cascadiaruby2012-therapeutic-refactoring">http://confreaks.com/videos/1071-cascadiaruby2012-therapeutic-refactoring</a>
  </p>
</section>

<section data-transition="none">
  <h1>Próximos pasos</h1>

  <h3><a target="_blank" href="http://robots.thoughtbot.com/sandi-metz-rules-for-developers">Las 4 reglas</a></h3>

  <p>Clases de <span style="color:#0f0">100 líneas</span> o menos
  <p>Métodos de <span style="color:#0f0">5 líneas</span> o menos
  <p>Métodos con <span style="color:#0f0">4 argumentos</span> o menos
  <p>Un controlador instancia <span style="color:#0f0">sólo un objeto</span>

  <aside class="notes">
    <p>Hay docenas de patrones de diseño y de refactoring, hay muchas métricas de calidad para software

    <p>Son reglas simples para explicar y entender, e implican muchas buenas prácticas

    <p>Estas reglas llevan naturalmente a respetar esos patrones y métricas, sin necesidad de saber nombrarlas como niño dando la lección

    <p>Siguiendo estas simples reglas van a ir a buenos puertos

    <p>Cuánto refactorizar: until-you-feel-almost-comfortable
  </aside>
</section>


<section data-transition="none">
  <h1>Vimos</h1>

  <p>Código confuso -> <span style="color: green">Método que revela la intención</span>

  <p> <tt>"Undefined method on nil"</tt> -> <span style="color: green">Objecto Nulo</span><br>

  <p>Un Método Gigante -> <span style="color: green">Reemplazar con "Method Object"</span>
</section>

<section data-transition="none">
  <h1>Preguntas!</h1>

  <p>tutecosta@gmail.com - https://github.com/tute</p>
  <p>
    <small>Principal Engineer at</small>
    <br>
    EpionHealth.com
  </p>

  <img src="imgs/eh.png" width="600">

  <div class="fragment">
    <tt>nil</tt> 🤓
  </div>

  <aside class="notes" data-markdown>
    Soy Tute Costa, trabajo remotamente para Epion Health, una empresa relacionada a la Salud de Estados Unidos.

    Nuestra aplicación "check in" permite a pacientes completar los formularios médicos necesarios antes de ver a su médico, de manera simple y rápida desde un iPad o desde sus teléfonos.

    Procesamos 30.000 check-ins por día, y somos buenos amigos con `nil` desde que empezó el proyecto, 7 años atrás (2015). La empresa está creciendo así que hay diversión para rato.
  </aside>
</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>

	</body>
</html>
